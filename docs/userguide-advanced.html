<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.0/sandstone/bootstrap.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/solarized-light.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-grid.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-theme-balham.min.css" rel="stylesheet" type="text/css">
        <link href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    </head>
    <body>
        <p id="loading">Loading ...</p>
        <div id="app"></div>
    </body>
    <script src="https://cdn.statically.io/gh/scicloj/gorilla-notes@master/dist/0.5.10/main.js"></script>
    <script>
     shadow.loader.load("main");
     gorilla_notes.main.main_BANG_(false, "{:options {:reverse-notes? false, :header? false, :notes-in-cards? false, :initially-collapse? false, :auto-scroll? false, :port 1903, :custom-header [:div {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} \"(notespace)\" [:p \"Wed Apr 21 16:52:52 CEST 2021\"] nil [:hr]], :custom-footer [:div [:hr] [:hr]]}, :ids [\"861\" \"700\" \"862\" \"863\" \"864\" \"865\" \"866\" \"867\" \"325\" \"868\" \"589\" \"869\" \"870\" \"708\" \"871\" \"710\" \"711\" \"872\" \"873\" \"874\" \"713\" \"875\" \"715\" \"876\" \"877\" \"718\" \"719\" \"602\" \"491\" \"878\" \"721\" \"493\" \"494\" \"495\" \"879\" \"351\" \"352\" \"880\" \"881\" \"498\" \"605\" \"606\" \"500\" \"882\" \"502\" \"883\" \"884\" \"175\" \"609\" \"727\" \"506\" \"728\" \"729\" \"612\" \"613\" \"885\" \"886\" \"887\" \"732\" \"888\" \"734\" \"616\" \"889\" \"890\" \"509\" \"510\" \"891\" \"892\" \"893\" \"894\" \"895\" \"896\" \"897\" \"898\" \"899\" \"900\" \"796\" \"901\" \"902\" \"799\" \"800\" \"903\" \"904\" \"803\" \"905\" \"906\" \"907\" \"908\" \"909\" \"910\" \"911\" \"912\" \"812\" \"813\" \"913\" \"914\" \"915\" \"916\" \"917\" \"918\" \"919\" \"920\" \"921\" \"922\" \"923\" \"924\" \"925\" \"926\" \"828\" \"927\" \"928\" \"831\" \"929\" \"833\" \"834\" \"835\" \"930\" \"837\" \"931\" \"932\" \"933\" \"841\" \"934\" \"935\" \"936\" \"937\" \"846\" \"847\" \"938\" \"939\" \"940\" \"941\" \"852\" \"942\" \"854\" \"943\" \"944\" \"857\" \"858\" \"945\" \"860\"], :id->content {\"728\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-inline {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n\\n\"}]], \"945\" [:div [:p] nil nil nil], \"867\" [:div [:p] nil nil [:p/markdown \"By default the value of `:metamorph/id` is set to a unique uuid. In some cases it can be useful to overwrite this auto-generated id.\\nThis can be done by pre-pending any step function with a map. The map gets merged with the usual context map for this step, before the\\nstep function is executed:\\n\"]], \"831\" [:div [:p] nil nil [:p/markdown \"This gives 2 * 10 = 20 results:\"]], \"941\" [:div [:p] [:div [:p/code {:code \"(seq\\n (.coefficients best-logistic-regression-model))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"(-0.3875017962379609 0.7260947693258564)\\n\"}]], \"612\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-mm {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n\\n\"}]], \"498\" [:div [:p] nil nil [:p/markdown \"We can define inline a metamorph compliant function as anonymous function.\"]], \"813\" [:div [:p] [:div [:p/code {:code \"(def train-test-data-pairs (ds/split->seq titanic-data :holdout))\", :bg-class \"bg-light\"}]] nil nil], \"719\" [:div [:p] nil nil [:p/markdown \"### Custom metamorph compliant function\"]], \"910\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (mm/select-columns [:Survived :Pclass ])\\n   (mm/categorical->number [:Survived :Pclass])\\n   (mm/set-inference-target :Survived)\\n   (mm/model {:model-type :smile.classification/logistic-regression})))\", :bg-class \"bg-light\"}]] nil nil], \"616\" [:div [:p] nil nil [:p/markdown \"The pipeline has only one step, the model function itself.\"]], \"932\" [:div [:p] [:div [:p/code {:code \"(def all-options\\n  (->>\\n   (ml/sobol-gridsearch {:max-iterations (ml/linear 1 1000)\\n                         :lambda (ml/linear 0 1)\\n                          :tolerance (ml/linear 1e-9 1e-1 20)\\n                         })\\n   (take 20)))\", :bg-class \"bg-light\"}]] nil nil], \"865\" [:div [:p] nil nil [:p/markdown \"`:metamorph/mode` is used by 'model' functions, which get fitted from data or transform data.\\nTwo modes are standardized, namely: `:fit` and `:transform`. In machine learning they often are called train / predict.\\n`sciform.ml` requires them to be `:fit` and `:transform`, and\\nthird party libraries should adhere to this convention.\\n\"]], \"175\" [:div [:p] nil nil [:p/markdown \"We write directly a metamorph compliant, named , function.\\nThe body of the function is the same as the body of the inline function from before.\\n\"]], \"896\" [:div [:p] nil nil [:p/markdown \"As the context is a normal map, we can store arbitrary data in it. This means normally, that two steps work\\ntogether in some form, and a former steps writes some data to the ctx under a `known` key, which the later step\\nreads from the pipeline under this `known, shared` key.\\nThe use cases for this  are left for the user of `scicloj.ml` to decide, the library does not interfere in this.\\n\\nThe moment these functions become re-usable and are eventually added to a library, namespaced keywords should\\nbe used for the keys in order to avoid name collisions.\\n\\nTypical use cases might be:\\n\\n1. Some values of the dataset have been converted in some form, and we need to keep some information to convert them back\\n2. In a Natural Language Processing pipeline, the vocabulary is generated in one pipeline step, and needs to be used later\\n3. Some non-tabular data is generated during pipeline execution and should be kept somewhere\\n\\nThis features makes sure, that a pipeline can stay 100 % self-contained,\\nwhatever data needed to be stored and makes the metamorph pipeline concept future-proof.\\n\\n\"]], \"883\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-lift\\n  (ml/pipeline\\n   (ml/lift ds->cat)))\", :bg-class \"bg-light\"}]] nil nil], \"939\" [:div [:p] [:div [:p/code {:code \"best-logistic-regression-model\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#object[smile.classification.LogisticRegression$Binomial 0x7cf4d43c \\\"smile.classification.LogisticRegression$Binomial@7cf4d43c\\\"]\\n\"}]], \"857\" [:div [:p] [:div [:p/code {:code \"(->\\n (best-pipe-fn\\n  (merge best-fit-ctx\\n         {:metamorph/data (-> titanic-data  (ds/shuffle {:seed 123})  (ds/head 10))\\n          :metamorph/mode :transform\\n          }))\\n :metamorph/data\\n (ds/column-values->categorical :Survived))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#tech.v3.dataset.column<string>[10]\\n:Survived\\n[1, 1, 0, 0, 0, 0, 0, 0, 0, 0]\\n\"}]], \"914\" [:div [:p] nil nil [:p/markdown \"The result contains quite some information, I remove here the binary representation of\\nthe model for pretty printing purposes.\"]], \"930\" [:div [:p] nil nil [:p/markdown \"This function can now be called to produce a pipeline fn:\"]], \"913\" [:div [:p] [:div [:p/code {:code \"(def eval-results (ml/evaluate-pipelines all-pipelines\\n                                        train-test-data-pairs\\n                                        ml/classification-accuracy\\n                                        :accuracy))\", :bg-class \"bg-light\"}]] nil nil], \"923\" [:div [:p] [:div [:p/code {:code \"(def train-test-data-pairs (ds/split->seq titanic-data :kfold {:k 10}))\", :bg-class \"bg-light\"}]] nil nil], \"911\" [:div [:p] nil nil [:p/markdown \"The sequence of pipeline functions consists for this example of a sequence with a single pipeline.\"]], \"875\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (fn [ctx] (def ctx-1 ctx) ctx)\\n   (mm/select-columns [:time])\\n   (fn [ctx] (def ctx-2 ctx) ctx)\\n   ;; (mm/step-2)\\n   ;; (mm/step-3)\\n   ;; (mm/step-4)\\n   ))\", :bg-class \"bg-light\"}]] nil nil], \"613\" [:div [:p] nil nil [:p/markdown \"### Custom model function\"]], \"715\" [:div [:p] [:div [:p/code {:code \"(def ctx\\n  (pipe-fn {:metamorph/data train-data\\n            :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"885\" [:div [:p] nil nil [:p/markdown \"In this chapter we see how to build a custom metamorph compliant function, which behaves like a simple model.\\nIt takes the mean of the training data and applies this the to the test data.\\n\"]], \"927\" [:div [:p] [:div [:p/code {:code \"(def all-pipelines [pipe-fn-1 pipe-fn-2])\", :bg-class \"bg-light\"}]] nil nil], \"884\" [:div [:p] nil nil [:p/markdown \"### Metamorph compliant function\"]], \"943\" [:div [:p] [:div [:p/code {:code \"(def best-fit-ctx\\n  (:fit-ctx best-result ))\", :bg-class \"bg-light\"}]] nil nil], \"871\" [:div [:p] nil nil [:p/markdown \"A metamorph pipeline can be debugged by two simple techniques.\"]], \"908\" [:div [:p] [:div [:p/code {:code \"(def titanic-data\\n  (->   (ds/dataset \\\"https://github.com/scicloj/metamorph-examples/raw/main/data/titanic/train.csv\\\"\\n                    {:key-fn keyword\\n                     :parser-fn :string\\n                     })))\", :bg-class \"bg-light\"}]] nil nil], \"700\" [:div [:p] [:div [:p/code {:code \"(require  '[scicloj.ml.core :as ml]\\n          '[scicloj.ml.metamorph :as mm]\\n          '[scicloj.ml.dataset :as ds]\\n          '[tech.v3.datatype.functional :as fun]\\n          )\", :bg-class \"bg-light\"}]] nil nil], \"916\" [:div [:p] nil nil [:p/markdown \"On high level, the result contains for every fold and every pipe-fn\\n (in this example we have only one), these keys with the\\nevaluation metrics and other information\"]], \"942\" [:div [:p] [:div [:p/code {:code \"(def best-pipe-fn\\n  (:pipe-fn best-result ))\", :bg-class \"bg-light\"}]] nil nil], \"925\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-1\\n  (ml/pipeline\\n   (mm/select-columns [:Survived :Pclass ])\\n   (mm/categorical->number [:Survived :Pclass])\\n   (mm/set-inference-target :Survived)\\n   (mm/model {:model-type :smile.classification/logistic-regression\\n              :max-iterations 1})))\", :bg-class \"bg-light\"}]] nil nil], \"861\" [:div [:p] nil nil nil], \"868\" [:div [:p] nil nil [:p/markdown \"This map can have any key / value, which might be useful for injecting other static data into the pipeline.\"]], \"732\" [:div [:p] [:div [:p/code {:code \"(def test-data\\n  (ds/dataset {:time [11 12 13 14 15]\\n               :val [nil nil  nil nil nil ]}))\", :bg-class \"bg-light\"}]] nil nil], \"877\" [:div [:p] [:div [:p/code {:code \"ctx-2\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n|  :time |\\n|--------|\\n|      1 |\\n|      2 |\\n|      3 |\\n, :mode :fit, :id #uuid \\\"5e98cb71-34e1-4b75-b622-7636ac9ba77a\\\"}\\n\"}]], \"894\" [:div [:p] [:div [:p/code {:code \"prediction\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [5 2]:\\n\\n|  :time |     :val |\\n|--------|----------|\\n|     11 |     11.9 |\\n|     12 |     11.9 |\\n|     13 |     11.9 |\\n|     14 |     11.9 |\\n|     15 |     11.9 |\\n\\n\"}]], \"887\" [:div [:p] [:div [:p/code {:code \"(def train-data\\n  (ds/dataset {:time [1 2 3 4 5 6 7 8 9 10]\\n               :val [1 3 4 4 20 3 4 18 39 23]}))\", :bg-class \"bg-light\"}]] nil nil], \"605\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-inline\\n  (ml/pipeline\\n   (fn [{:metamorph/keys [data]}]\\n     (ds/add-or-replace-column data :val (fn [ds] (map ->cat (:val ds)))))))\", :bg-class \"bg-light\"}]] nil nil], \"493\" [:div [:p] nil nil [:p/markdown \"Most steps of a pipeline are about modifying the dataset, so most custom code will be here.\\nIn machine learning, this is as well known as feature engineering, as new features get created\\nfrom existing features.\"]], \"890\" [:div [:p] nil nil [:p/markdown \"We run the training as usual, passing a map of data and mode :fit. (The id gets added automatically)\"]], \"858\" [:div [:p] nil nil [:p/markdown \"### Handling of categorical data\"]], \"727\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-mm\\n  (ml/pipeline\\n   (mm->cat)))\", :bg-class \"bg-light\"}]] nil nil], \"903\" [:div [:p] [:div [:p/code {:code \"(def train-test-data-pairs\\n  ;; some form of split of test data, such as:\\n  ;; holdout\\n  ;; k-fold\\n  ;; leave-one-out\\n  )\", :bg-class \"bg-light\"}]] nil nil], \"609\" [:div [:p] [:div [:p/code {:code \"(defn mm->cat []\\n  (fn [{:metamorph/keys [data]}]\\n    (ds/add-or-replace-column data :val (fn [ds] (map ->cat (:val ds))))))\", :bg-class \"bg-light\"}]] nil nil], \"837\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn (create-pipe-fn {:max-iterations 1}))\", :bg-class \"bg-light\"}]] nil nil], \"898\" [:div [:p] nil nil [:p/markdown \"In machine learning we come at a certain moment of the development of\\na data pipeline or a model to a point where we do not know any more for sure, if a certain\\nmodification of the pipeline or the model will improve the predictive\\nperformance any further or not.\"]], \"882\" [:div [:p] [:div [:p/code {:code \"(defn ds->cat [ds]\\n  (ds/add-or-replace-column ds :val (fn [ds] (map ->cat (:val ds)))))\", :bg-class \"bg-light\"}]] nil nil], \"888\" [:div [:p] nil nil [:p/markdown \"Next we create the model function. It makes use of namespaced\\nkey destructuring, which allows very compact code.\\n\\nThe :id,:data and :mode keys from the context,\\nbecome local bindings.\\n\\nIn :mode :fit, we calculate the mean of the (training) data and store it in ctx under an `id` which is passed to\\nthe function by `metamorph` and is a unique id of the step.\\nThis we use then as key to store the mean in the context, so that in :transform we can read it from the ctx under the same `id`.\\nThe `id` passed into the function is the same in :fit and :transform (but unique per step)\\nSo we see how to pass data from the same function in the pipeline run in mode :fit to the\\nrun in mode :transform.\\n\\nConceptually this function is a pair of train/predict functions, which behaves like `train` in mode :fit and\\n`predict` in mode :transform.\\n\"]], \"901\" [:div [:p] nil nil [:p/markdown \"The working horse for this is the `scicloj.ml/evaluate-pipelines` function.\\nIt takes as basic input a `sequence of pipeline functions` , a `sequence of pairs of train and test datasets`\\nand  a `metric function`. It will then do a nested loop of all pipelines and all\\ntrain/test pairs and calculate the given  model metrics for all combinations.\\n(which means to `train` and `evaluate` all pipelines using the train/test dataset pairs. \"]], \"938\" [:div [:p] [:div [:p/code {:code \"(def best-logistic-regression-model\\n  (ml/thaw-model (get-in best-result [:fit-ctx :model] )))\", :bg-class \"bg-light\"}]] nil nil], \"924\" [:div [:p] nil nil [:p/markdown \"And then we just create two pipeline function via copy/paste/adapt.\\n(In reality we wanted to do this with a pipeline creating function taking parameters, see below).\\n\"]], \"862\" [:div [:p] nil nil [:p/markdown \"### Special keys in metamorph context map\"]], \"860\" [:div [:p] nil nil nil], \"876\" [:div [:p] [:div [:p/code {:code \"ctx-1\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 2]:\\n\\n|  :time |   :val |\\n|--------|--------|\\n|      1 |      1 |\\n|      2 |      3 |\\n|      3 |      4 |\\n, :mode :fit, :id #uuid \\\"3bd1ab16-81ce-4a1d-9565-ae9c86132ae8\\\"}\\n\"}]], \"904\" [:div [:p] [:div [:p/code {:code \"(comment\\n  (ml/evaluate-pipelines all-pipelines train-test-data-pairs ml/classification-accuracy :accuracy))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"nil\\n\"}]], \"833\" [:div [:p] nil nil [:p/markdown \"#### Evaluate several pipeline with Titanic example - grid search pipelines\"]], \"921\" [:div [:p] nil nil [:p/markdown \"#### Evaluate several pipeline fns using k-fold with Titanic example - 2 pipeline functions\"]], \"846\" [:div [:p] [:div [:p/code {:code \"(def best-result\\n  (->> eval-results\\n       flatten\\n       (sort-by :metric)\\n       last))\", :bg-class \"bg-light\"}]] nil nil], \"852\" [:div [:p] nil nil [:p/markdown \"Or taking the best pipeleine,\"]], \"878\" [:div [:p] nil nil [:p/markdown \"1. Data manipulation functions. Use only :metamorph/data .\\n  2. Model type of functions. They use :metamorph/data , :metamorph/mode and :metamorph/id  and behave different in mode :fit and :mode transform. Eventually they use other keys in the context.\\n  2a. This variants of type 2), might use non standard keys to pass data between different steps and therefore collaborate.\\n\"]], \"873\" [:div [:p] [:div [:p/code {:code \"(def trained-ctx\\n  (pipe-fn {:metamorph/data train-data\\n            :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"721\" [:div [:p] nil nil [:p/markdown \"## Custom dataset->dataset transforming functions \"]], \"919\" [:div [:p] nil nil [:p/markdown \"We can get the accuracy of the one result by doing:\"]], \"936\" [:div [:p] [:div [:p/code {:code \"(frequencies\\n (map :metric\\n      (flatten eval-results)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"{0.6 10,\\n 0.6333333333333333 11,\\n 0.5 20,\\n 0.5222222222222223 20,\\n 0.6555555555555556 10,\\n 0.6222222222222222 11,\\n 0.5888888888888889 9,\\n 0.5555555555555556 20,\\n 0.5432098765432098 20,\\n 0.6888888888888889 20,\\n 0.611111111111111 9,\\n 0.6444444444444444 20,\\n 0.6777777777777778 20}\\n\"}]], \"799\" [:div [:p] nil nil [:p/markdown \"By leaving it to the user to provide the seq of pipeline-fns, the sequence of train/test pairs and teh metric function,\\nthe `evaluate-pipelines` function can be applied to a large variety of used cases. We will see below some examples, how to generate this\\nsequences.\"]], \"874\" [:div [:p] [:div [:p/code {:code \"trained-ctx\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n|  :time |\\n|--------|\\n|      1 |\\n|      2 |\\n|      3 |\\n, :mode :fit}\\n\"}]], \"891\" [:div [:p] [:div [:p/code {:code \"(def predicted-ctx\\n  (pipe-fn\\n   (merge trained-ctx\\n          {:metamorph/data test-data\\n           :metamorph/mode :transform})))\", :bg-class \"bg-light\"}]] nil nil], \"718\" [:div [:p] nil nil [:p/markdown \"The context contains as well the dataset, which could be large.\\n So other tools for inspecting Clojure maps are usefull.\"]], \"872\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (mm/select-columns [:time])\\n   ;; (mm/step-2)\\n   ;; (mm/step-3)\\n   ;; (mm/step-4)\\n   ))\", :bg-class \"bg-light\"}]] nil nil], \"886\" [:div [:p] nil nil [:p/markdown \"Here we create dummy training data, which is like a time series.\\nWe have values for time step 1-10, and want to predict (using the mean),\\nthe value for future time steps.\\n\"]], \"352\" [:div [:p] nil nil [:p/markdown \"We have now three different ways to write a metamorph compliant function\"]], \"854\" [:div [:p] nil nil [:p/markdown \"the best context\"]], \"918\" [:div [:p] nil nil [:p/markdown \"By default the `evaluate-pipeline` filters out the datasets already from the result,\\nwhich would else wise be in as well. This can be configured in the options when calling it.\"]], \"928\" [:div [:p] [:div [:p/code {:code \"(def eval-results (ml/evaluate-pipelines all-pipelines\\n                                         train-test-data-pairs\\n                                         ml/classification-accuracy\\n                                         :accuracy\\n                                         ;; we return results of all pipelines and all folds\\n                                         ;; By default only the best fold of the best pipeline is returned\\n                                         {:return-best-pipeline-only false\\n                                          :return-best-crossvalidation-only false\\n                                          }\\n\\n                                         ))\", :bg-class \"bg-light\"}]] nil nil], \"870\" [:div [:p] nil nil [:p/markdown \"These are then used by function `scicloj.ml.core/evaluate-pipelines` to do performance measurements of a model\"]], \"915\" [:div [:p] [:div [:p/code {:code \"(remove-deep\\n [:model-data]\\n eval-results)\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"(({:pipe-fn\\n   #function[scicloj.metamorph.core/pipeline/local-pipeline--38588],\\n   :min 0.6262626262626263,\\n   :mean 0.6262626262626263,\\n   :fit-ctx\\n   {:metamorph/mode :fit,\\n    #uuid \\\"e501d0f2-8895-472f-9032-dc771d23d27c\\\"\\n    {:options {:model-type :smile.classification/logistic-regression},\\n     :id #uuid \\\"13afeba3-f814-49c5-b6f1-cd833e2eb2c0\\\",\\n     :feature-columns [:Pclass],\\n     :target-columns [:Survived],\\n     :target-categorical-maps\\n     {:Survived\\n      {:lookup-table {\\\"1\\\" 0, \\\"0\\\" 1},\\n       :src-column :Survived,\\n       :result-datatype :float64}}}},\\n   :metric-fn\\n   #function[scicloj.metamorph.ml.loss/classification-accuracy],\\n   :max 0.6262626262626263,\\n   :timing {:fit 1, :transform 2},\\n   :transform-ctx\\n   {:metamorph/mode :transform,\\n    #uuid \\\"e501d0f2-8895-472f-9032-dc771d23d27c\\\"\\n    {:options {:model-type :smile.classification/logistic-regression},\\n     :id #uuid \\\"13afeba3-f814-49c5-b6f1-cd833e2eb2c0\\\",\\n     :feature-columns [:Pclass],\\n     :target-columns [:Survived],\\n     :target-categorical-maps\\n     {:Survived\\n      {:lookup-table {\\\"1\\\" 0, \\\"0\\\" 1},\\n       :src-column :Survived,\\n       :result-datatype :float64}}}},\\n   :metric 0.6262626262626263}))\\n\"}]], \"606\" [:div [:p] nil nil [:p/markdown \"### Lift a dataset->dataset function\"]], \"710\" [:div [:p] nil nil [:p/markdown \"The first is to comment out parts of the pipeline, run it and\\n inspect the pipe-fn result, namely the context.\"]], \"835\" [:div [:p] [:div [:p/code {:code \"(defn create-pipe-fn [params]\\n  (ml/pipeline\\n   (mm/select-columns [:Survived :Pclass ])\\n   (mm/categorical->number [:Survived :Pclass])\\n   (mm/set-inference-target :Survived)\\n   {:metamorph/id :model} (mm/model (merge {:model-type :smile.classification/logistic-regression}\\n                    params))))\", :bg-class \"bg-light\"}]] nil nil], \"863\" [:div [:p] nil nil [:p/markdown \"A metamorph context map can contain arbitrary keys. Three keys are\\n special and they enable the functioning of the pipeline . All steps should\\nhandle them in the same way.\"]], \"502\" [:div [:p] nil nil [:p/markdown \"and then we include it into the pipeline via\\nlifting the ds->ds function into\\na :metamorph/data -> :metamorph/data function\"]], \"510\" [:div [:p] nil nil [:p/markdown \"Same for the prediction, in mode :transform, merging in the trained-ctx but overwriting data and mode\"]], \"325\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n;;  step 1\\n;;  step 2\\n   {:metamorph/id :my-model} (mm/select-columns [:time])\\n   ))\", :bg-class \"bg-light\"}]] nil nil], \"880\" [:div [:p] nil nil [:p/markdown \"1. Inline\\n  2. Lifting\\n  3. Named function\\n\"]], \"812\" [:div [:p] nil nil [:p/markdown \"For creating train/test pairs, the function `scicloj.ml.dataset/split->seq`\\n creates them in the right format (list of maps with keys :train and :test and value being\\na `tech.ml.dataset`)\"]], \"864\" [:div [:p] nil nil [:p/markdown \" `:metamorph/data` contains the main data object, the pipeline\\n is supposed to manipulate. The type of object can be anything, but all\\nfunctionality on `scicloj.ml` requires it to be a `tech.v3.dataset`\\n instance. For further information see in\\n [metamorph](https://github.com/scicloj/metamorph)\"]], \"929\" [:div [:p] [:div [:p/code {:code \"(map  :metric (flatten eval-results))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"(0.5777777777777778\\n 0.5888888888888889\\n 0.5888888888888889\\n 0.6\\n 0.6049382716049383\\n 0.611111111111111\\n 0.6222222222222222\\n 0.6444444444444444\\n 0.6555555555555556\\n 0.6666666666666667\\n 0.5\\n 0.5222222222222223\\n 0.5432098765432098\\n 0.5555555555555556\\n 0.6222222222222222\\n 0.6333333333333333\\n 0.6444444444444444\\n 0.6555555555555556\\n 0.6777777777777778\\n 0.6888888888888889)\\n\"}]], \"895\" [:div [:p] nil nil [:p/markdown \"### Keep auxiliary data in pipeline\"]], \"935\" [:div [:p] nil nil [:p/markdown \"This gives 10 * 20 = 10 model performance results, for which I print here teh distribution:\"]], \"902\" [:div [:p] nil nil [:p/markdown \"By preparing the seq of pipelines and the seq of train/test pairs accordingly,\\nvarious types of grid search with various cross-validation schemes can be realized.\"]], \"729\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-lift {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n}\\n\"}]], \"602\" [:div [:p] nil nil [:p/markdown \"Custom steps in metamorph pipelines are normal Clojure functions.\"]], \"828\" [:div [:p] nil nil [:p/markdown \"Just create seq of 2 pipeline functions\"]], \"881\" [:div [:p] nil nil [:p/markdown \"### Inline fn\"]], \"926\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-2\\n  (ml/pipeline\\n   (mm/select-columns [:Survived :Pclass ])\\n   (mm/categorical->number [:Survived :Pclass])\\n   (mm/set-inference-target :Survived)\\n   (mm/model {:model-type :smile.classification/logistic-regression\\n              :max-iterations 1000})))\", :bg-class \"bg-light\"}]] nil nil], \"509\" [:div [:p] [:div [:p/code {:code \"(def trained-ctx\\n  (pipe-fn {:metamorph/data train-data\\n         :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"734\" [:div [:p] [:div [:p/code {:code \"(defn mean-model []\\n  (fn [{:metamorph/keys [id data mode] :as ctx}]\\n    (case mode\\n      :fit\\n      (let [vals-so-far (-> data :val seq)\\n            mean-so-far (fun/mean vals-so-far)\\n            ]\\n        (assoc ctx id mean-so-far)\\n        )\\n      :transform\\n      (let [mean-so-far (get ctx id)\\n            updated-ds (-> data\\n                           (ds/add-or-replace-column :val mean-so-far ))]\\n        (assoc ctx :metamorph/data updated-ds)))))\", :bg-class \"bg-light\"}]] nil nil], \"909\" [:div [:p] nil nil [:p/markdown \"Now we create a seq of pipeline fns, in this case having only **one** pipeline function\"]], \"841\" [:div [:p] [:div [:p/code {:code \"(def all-pipelines\\n  (map create-pipe-fn all-options))\", :bg-class \"bg-light\"}]] nil nil], \"906\" [:div [:p] nil nil [:p/markdown \"We will reuse the example from the Introduction user guide.\"]], \"847\" [:div [:p] nil nil [:p/markdown \"Out of this can get the trained logistic regression model (in this case a Smile Java object), \"]], \"917\" [:div [:p] [:div [:p/code {:code \"(keys (first (first eval-results)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"(:pipe-fn\\n :min\\n :mean\\n :fit-ctx\\n :metric-fn\\n :max\\n :timing\\n :transform-ctx\\n :metric)\\n\"}]], \"500\" [:div [:p] nil nil [:p/markdown \"Here we first create a function which manipulates the dataset as we want\"]], \"937\" [:div [:p] nil nil [:p/markdown \"Sorting the result by metric and taking the last, we can get the `best` performing model\"]], \"803\" [:div [:p] nil nil [:p/markdown \"This will return the evaluations as a sequence of maps, as explained below.\"]], \"495\" [:div [:p] nil nil [:p/markdown \"Lets take as an example, a function which encodes a column with a numerical value to 3 categorical values:\\n\\n\\n - < 0         -> :negative\\n - > 0 - 1000  -> :low\\n - > 1000      -> :high\\n\\n \"]], \"866\" [:div [:p] nil nil [:p/markdown \"`:metamorph/id` contains at every step a different , unique, id. A model function can use it\\nto store the trained model in :fit and use it it :transform for prediction\"]], \"491\" [:div [:p] nil nil [:p/markdown \"Conceptually we have three types of functions, they differ by which keys in\\n the context they manipulate.\"]], \"708\" [:div [:p] nil nil [:p/markdown \"## Debugging a metamorph pipeline\"]], \"711\" [:div [:p] [:div [:p/code {:code \"(def train-data\\n  (ds/dataset {:time [1 2 3]\\n               :val [1 3 4]}))\", :bg-class \"bg-light\"}]] nil nil], \"940\" [:div [:p] nil nil [:p/markdown \"to inspect its internals, like coefficients: \"]], \"899\" [:div [:p] nil nil [:p/markdown \"In this situation we can think about trying out all different pipeline\\nor model parameters and select the best automatically. In the context of the\\nmodel, this is typically called `hyper-parameter tuning`\"]], \"796\" [:div [:p] nil nil [:p/markdown \"#### evaluate-pipelines function\"]], \"506\" [:div [:p] nil nil [:p/markdown \"The results of applying all 3 pipeline functions is the same.\"]], \"589\" [:div [:p] nil nil [:p/markdown \"Two functions in `scicloj.ml` use two further keys with the purpose of model evaluation, see further down in this guide.\"]], \"920\" [:div [:p] [:div [:p/code {:code \"(:metric (first (first eval-results)))\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"0.6262626262626263\\n\"}]], \"934\" [:div [:p] [:div [:p/code {:code \"(def eval-results (ml/evaluate-pipelines all-pipelines\\n                                         train-test-data-pairs\\n                                         ml/classification-accuracy\\n                                         :accuracy\\n                                         {:return-best-pipeline-only false\\n                                          :return-best-crossvalidation-only false\\n                                          }))\", :bg-class \"bg-light\"}]] nil nil], \"879\" [:div [:p] nil nil [:p/markdown \"First a helper function which does the above transformation of a single value\"]], \"905\" [:div [:p] nil nil [:p/markdown \"#### Evaluate one pipeline function with Titanic example   \"]], \"713\" [:div [:p] nil nil [:p/markdown \"The second alternative is to capture the state of the ctx in arbitrary\\n steps.\"]], \"897\" [:div [:p] nil nil [:p/markdown \"### Pipeline evaluation and selection\"]], \"922\" [:div [:p] nil nil [:p/markdown \"First we will generate seq of 10 pairs of train/test using k-fold\"]], \"494\" [:div [:p] nil nil [:p/markdown \"For a custom data manipulation function to be able to participate in a metamorph pipeline\\nit needs to:\\n\\n1. Take a context map as input\\n2. Return a context map\\n3. Modify the dataset at key :metamorph/data\\n4. Not change any other key ctx\\n\\n\"]], \"900\" [:div [:p] nil nil [:p/markdown \"Differently to other machine learning frameworks, `scicloj.ml` does not only\\nallow to hyper-tune the model parameters but as well the whole transformation pipeline.\"]], \"933\" [:div [:p] nil nil [:p/markdown \"This will produce an optimized search grid of all values between 1 1000, by taking first larger and then smaller intervals.\\nSo taking the first 20 of these covers already the full space. See help of the ml/sobol-gridsearch for more information\\nThis gives us 20 grid points for our parameter search, which we can easily transform in a sequence 10 pipeline functions:\"]], \"907\" [:div [:p] nil nil [:p/markdown \"First the data:\"]], \"834\" [:div [:p] nil nil [:p/markdown \"Now we will generate our seq of pipeline functions.\\nFirst we need a function which creates a pipeline function from parameters:\"]], \"351\" [:div [:p] [:div [:p/code {:code \"(defn ->cat [x]\\n  (cond (< x 0 )          :negative\\n        (and (pos? x)\\n             (< x 1000) ) :low\\n        true              :high))\", :bg-class \"bg-light\"}]] nil nil], \"889\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (mean-model)\\n   ))\", :bg-class \"bg-light\"}]] nil nil], \"931\" [:div [:p] nil nil [:p/markdown \"But we go one step further already and grid search over potential values using sobol sequences\"]], \"800\" [:div [:p] [:div [:p/code {:code \"(def all-pipelines\\n  ;; whatever needed to get all pipeline fns\\n  ;; typically these are variations of one single pipeline, where some parameters are different\\n  ;; (but this is not required, the pipelines can be completely different)\\n  )\", :bg-class \"bg-light\"}]] nil nil], \"869\" [:div [:p] nil nil [:p/markdown \"The function `scicloj.ml.core/model` stores the feature-dataset and the inference-target-dataset in the ctx before doing a prediction\\nat keys `:scicloj.metamorph.ml/feature-ds` and  `:scicloj.metamorph.ml/target-ds`\"]], \"912\" [:div [:p] [:div [:p/code {:code \"(def all-pipelines [pipe-fn])\", :bg-class \"bg-light\"}]] nil nil], \"944\" [:div [:p] nil nil [:p/markdown \"and use this for predicting on new data:\"]], \"893\" [:div [:p] [:div [:p/code {:code \"(def prediction\\n  (:metamorph/data predicted-ctx))\", :bg-class \"bg-light\"}]] nil nil], \"892\" [:div [:p] nil nil [:p/markdown \"This runs the pipeline again and we have the prediction available in :metamorph/data\"]]}}");
     document.getElementById("loading").remove();
    </script>
</html>
