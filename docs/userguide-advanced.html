<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.0/sandstone/bootstrap.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/solarized-light.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-grid.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-theme-balham.min.css" rel="stylesheet" type="text/css">
        <link href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    </head>
    <body>
        <p id="loading">Loading ...</p>
        <div id="app"></div>
    </body>
    <script src="https://cdn.statically.io/gh/scicloj/gorilla-notes@master/dist/0.5.10/main.js"></script>
    <script>
     shadow.loader.load("main");
     gorilla_notes.main.main_BANG_(false, "{:options {:reverse-notes? false, :header? false, :notes-in-cards? false, :initially-collapse? false, :auto-scroll? false, :port 1903, :custom-header [:div {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} \"(notespace)\" [:p \"Mon Apr 12 22:34:34 CEST 2021\"] nil [:hr]], :custom-footer [:div [:hr] [:hr]]}, :ids [\"389\" \"390\" \"212\" \"213\" \"391\" \"215\" \"216\" \"217\" \"392\" \"393\" \"220\" \"339\" \"222\" \"223\" \"394\" \"395\" \"396\" \"227\" \"397\" \"343\" \"398\" \"231\" \"345\" \"399\" \"400\" \"401\" \"402\" \"348\" \"403\" \"350\" \"289\" \"351\" \"404\" \"353\" \"354\" \"294\" \"295\" \"405\" \"355\" \"406\" \"299\" \"300\" \"407\" \"408\" \"358\" \"359\" \"305\" \"360\" \"307\" \"409\" \"361\" \"410\" \"411\" \"364\" \"365\" \"412\" \"367\" \"413\" \"369\" \"414\" \"415\" \"416\" \"417\" \"418\" \"419\" \"376\" \"377\" \"378\" \"420\" \"421\" \"422\" \"423\" \"424\" \"384\" \"425\" \"386\"], :id->content {\"392\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n;;  step 1\\n;;  step 2\\n   {:metamorph/id :my-model} (mm/select-columns [:time])\\n   ))\", :bg-class \"bg-light\"}]] nil nil], \"365\" [:div [:p] nil nil [:p/markdown \"### Custom model function\"]], \"422\" [:div [:p] nil nil [:p/markdown \"### Keep auxiliary data in pipeline\"]], \"402\" [:div [:p] nil nil [:p/markdown \"### Custom metamorph compliant function\"]], \"359\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-lift\\n  (ml/pipeline\\n   (ml/lift ds->cat)))\", :bg-class \"bg-light\"}]] nil nil], \"343\" [:div [:p] [:div [:p/code {:code \"trained-ctx\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n|  :time |\\n|--------|\\n|      1 |\\n|      2 |\\n|      3 |\\n, :mode :fit}\\n\"}]], \"419\" [:div [:p] [:div [:p/code {:code \"(def trained-ctx\\n  (pipe-fn {:metamorph/data train-data\\n         :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"227\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (mm/select-columns [:time])\\n   ;; (mm/step-2)\\n   ;; (mm/step-3)\\n   ;; (mm/step-4)\\n   ))\", :bg-class \"bg-light\"}]] nil nil], \"415\" [:div [:p] [:div [:p/code {:code \"(defn mean-model []\\n  (fn [{:metamorph/keys [id data mode] :as ctx}]\\n    (case mode\\n      :fit\\n      (let [vals-so-far (-> data :val seq)\\n            mean-so-far (fun/mean vals-so-far)\\n            ]\\n        (assoc ctx id mean-so-far)\\n        )\\n      :transform\\n      (let [mean-so-far (get ctx id)\\n            updated-ds (-> data\\n                           (ds/add-or-replace-column :val mean-so-far ))]\\n        (assoc ctx :metamorph/data updated-ds)))))\", :bg-class \"bg-light\"}]] nil nil], \"384\" [:div [:p] nil nil [:p/markdown \"### Model selection\"]], \"413\" [:div [:p] [:div [:p/code {:code \"(def train-data\\n  (ds/dataset {:time [1 2 3 4 5 6 7 8 9 10]\\n               :val [1 3 4 4 20 3 4 18 39 23]}))\", :bg-class \"bg-light\"}]] nil nil], \"408\" [:div [:p] [:div [:p/code {:code \"(defn ds->cat [ds]\\n  (ds/add-or-replace-column ds :val (fn [ds] (map ->cat (:val ds)))))\", :bg-class \"bg-light\"}]] nil nil], \"305\" [:div [:p] nil nil [:p/markdown \"### Metamorph compliant function\"]], \"411\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-lift {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n}\\n\"}]], \"300\" [:div [:p] nil nil [:p/markdown \"### Lift a dataset->dataset function\"]], \"364\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-mm {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n\\n\"}]], \"404\" [:div [:p] nil nil [:p/markdown \"For a custom data manipulation function to be able to participate in a metamorph pipeline\\nit needs to:\\n\\n1. Take a context map as input\\n2. Return a context map\\n3. Modify the dataset at key :metamorph/data\\n4. Not change any other key ctx\\n\\n\"]], \"391\" [:div [:p] nil nil [:p/markdown \" `:metamorph/data` contains the main data object, the pipeline\\n is supposed to manipulate. The type of object can be anything, but all\\nfunctionality on `scicloj.ml` requires it to be a `tech.v3.dataset`\\n instance. For further information see in\\n [metamorph](https://github.com/scicloj/metamorph)\"]], \"423\" [:div [:p] nil nil [:p/markdown \"As the context is a normal map, we can store arbitrary data in it. This means normaly, that two steps work\\ntogether in some form, and a former steps writes some data to the ctx under a `known` key, which the later step\\nreads from the pipeline under this `known, shared` key.\\nThe use cases for this  are left for the user of `scicloj.ml` to decide, the library does not interfer in this.\\n\\nThe moment these functions become re-usable and are eventaully added to a library, namespace keywords should\\nbe used for the keys in order to avoid name collisions.\\n\\nTypical use cases might be:\\n\\n1. Some values of the dataset have been converted in some form, and we need to keep some information to convert them back\\n2. In a Natural Languge Processing pipeline, the vocabular is generated in one pipeline step, and needs to be used later\\n3. Some non-tabular data is generated during pipeline execution and should be kept somewhere\\n\\nThis features makes sure, that a pipeline can stay 100 % self-contained,\\nwhatever data needed to be stored and makes the metamorph pipeline concept future-proof.\\n\\n\"]], \"295\" [:div [:p] nil nil [:p/markdown \"We have now three different ways to write a metamorph compliant function\"]], \"369\" [:div [:p] [:div [:p/code {:code \"(def test-data\\n  (ds/dataset {:time [11 12 13 14 15]\\n               :val [nil nil  nil nil nil ]}))\", :bg-class \"bg-light\"}]] nil nil], \"396\" [:div [:p] [:div [:p/code {:code \"(def train-data\\n  (ds/dataset {:time [1 2 3]\\n               :val [1 3 4]}))\", :bg-class \"bg-light\"}]] nil nil], \"394\" [:div [:p] nil nil [:p/markdown \"A metamorph pipeline can be debugged by two simple techniques.\"]], \"414\" [:div [:p] nil nil [:p/markdown \"Next we create the model function. It makes use of namespaced\\nkey destructuring, which allows very compact code.\\n\\nThe :id,:data and :mode keys from the context,\\nbecome local bindings.\\n\\nIn :mode :fit, we calculate the mean of the (training) data and store it in ctx under an `id` which is passed to\\nthe function by `metamorph` and is a unique id of the step.\\nThis we use then as key to store the mean in the context, so that in :transform we can read it from the ctx under the same `id`.\\nThe `id` passed into the function is the same in :fit and :transform (but unique per step)\\nSo we see how to pass data from the same function in the pipeline run in mode :fit to the\\nrun in mode :transform.\\n\\nConeceptualy this function is a pair of train/predict functions, which behaves like `train` in mode :fit and\\n`predict` in mode :transform.\\n\"]], \"355\" [:div [:p] nil nil [:p/markdown \"### Inline fn\"]], \"231\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (fn [ctx] (def ctx-1 ctx) ctx)\\n   (mm/select-columns [:time])\\n   (fn [ctx] (def ctx-2 ctx) ctx)\\n   ;; (mm/step-2)\\n   ;; (mm/step-3)\\n   ;; (mm/step-4)\\n   ))\", :bg-class \"bg-light\"}]] nil nil], \"395\" [:div [:p] nil nil [:p/markdown \"The first is to comment out parts of the pipeline, run it and\\n inspect the pipe-fn result, naimly the context.\"]], \"299\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-inline\\n  (ml/pipeline\\n   (fn [{:metamorph/keys [data]}]\\n     (ds/add-or-replace-column data :val (fn [ds] (map ->cat (:val ds)))))))\", :bg-class \"bg-light\"}]] nil nil], \"389\" [:div [:p] nil nil nil], \"425\" [:div [:p] nil nil [:p/markdown \"## More advanced use case, as we need to pass the vocab size between steps\"]], \"358\" [:div [:p] nil nil [:p/markdown \"and then we include it into the pipeline via\\nlifting the ds->ds function into\\na :metamorph/data -> :metamorph/data function\"]], \"345\" [:div [:p] [:div [:p/code {:code \"(def ctx\\n  (pipe-fn {:metamorph/data train-data\\n            :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"405\" [:div [:p] nil nil [:p/markdown \"1. Inline\\n  2. Lifting\\n  3. Named function\\n\"]], \"213\" [:div [:p] nil nil [:p/markdown \"A metamorph context map can contain arbitrary keys. Three keys are\\n special and they enable the functioning of the pipeline . All steps should\\nhandle them in the same way.\"]], \"401\" [:div [:p] nil nil [:p/markdown \"The context contains as well the dataset, which could be large.\\n So other tools for inspecting Clojure maps, are usefull.\"]], \"354\" [:div [:p] nil nil [:p/markdown \"First a helper function which does the above transformation of a single value\"]], \"350\" [:div [:p] nil nil [:p/markdown \"1. Data manipulation functions. Use only :metamorph/data .\\n  2. Model type of functions. They use :metamorph/data , :metamorph/mode and :metamorph/id  and behave different in mode :fit  and :mode transform. Eventually they use other keys in the context.\\n  2a. This variants of type 2), might use non standard keys to pass data between different steps and therefore colaborate.\\n\"]], \"294\" [:div [:p] [:div [:p/code {:code \"(defn ->cat [x]\\n  (cond (< x 0 )          :negative\\n        (and (pos? x)\\n             (< x 1000) ) :low\\n        true              :high))\", :bg-class \"bg-light\"}]] nil nil], \"420\" [:div [:p] [:div [:p/code {:code \"(def prediction\\n  (:metamorph/data predicted-ctx))\", :bg-class \"bg-light\"}]] nil nil], \"212\" [:div [:p] nil nil [:p/markdown \"### Special keys in metamorph context map\"]], \"400\" [:div [:p] [:div [:p/code {:code \"ctx-2\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 1]:\\n\\n|  :time |\\n|--------|\\n|      1 |\\n|      2 |\\n|      3 |\\n, :mode :fit, :id #uuid \\\"febf7258-36f6-4d46-86dc-859028db7dfc\\\"}\\n\"}]], \"386\" [:div [:p] nil nil nil], \"222\" [:div [:p] nil nil [:p/markdown \"These are then used by function `scicloj.ml.core/evaluate-pipelines` to do performace measurements of a model\"]], \"289\" [:div [:p] nil nil [:p/markdown \"## Custom dataset->dataset transforming functions \"]], \"307\" [:div [:p] [:div [:p/code {:code \"(defn mm->cat []\\n  (fn [{:metamorph/keys [data]}]\\n    (ds/add-or-replace-column data :val (fn [ds] (map ->cat (:val ds))))))\", :bg-class \"bg-light\"}]] nil nil], \"376\" [:div [:p] nil nil [:p/markdown \"Same for the prediction, in mode :transform, merging in the trained-ctx but overwriting data and mode\"]], \"360\" [:div [:p] nil nil [:p/markdown \"We write directly a metamorph compliant, named , function.\\nThe body of the function is the same as the body of the inline function from before.\\n\"]], \"399\" [:div [:p] [:div [:p/code {:code \"ctx-1\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"#:metamorph{:data _unnamed [3 2]:\\n\\n|  :time |   :val |\\n|--------|--------|\\n|      1 |      1 |\\n|      2 |      3 |\\n|      3 |      4 |\\n, :mode :fit, :id #uuid \\\"4254ab95-5d00-4926-a8b1-5e69cde4320e\\\"}\\n\"}]], \"223\" [:div [:p] nil nil [:p/markdown \"## Debugging a metamorph pipeline\"]], \"421\" [:div [:p] [:div [:p/code {:code \"prediction\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [5 2]:\\n\\n|  :time |     :val |\\n|--------|----------|\\n|     11 |     11.9 |\\n|     12 |     11.9 |\\n|     13 |     11.9 |\\n|     14 |     11.9 |\\n|     15 |     11.9 |\\n\\n\"}]], \"418\" [:div [:p] nil nil [:p/markdown \"We run the training as usual, passing a map of data and mode :fit. (The id gets added automatically)\"]], \"410\" [:div [:p] [:div [:p/code {:code \"(pipe-fn-inline {:metamorph/data (ds/dataset {:val [-2 100 2000]})})\", :bg-class \"bg-light\"}]] nil [:p/code {:code \"_unnamed [3 1]:\\n\\n|      :val |\\n|-----------|\\n| :negative |\\n|      :low |\\n|     :high |\\n\\n\"}]], \"216\" [:div [:p] nil nil [:p/markdown \"`:metamorph/id` contains at every step a different , unique, id. A model function can use it\\nto store the trained model in :fit and use it it :transform for prediction\"]], \"416\" [:div [:p] nil nil [:p/markdown \"The pipeline has only one step, the model function itself.\"]], \"217\" [:div [:p] nil nil [:p/markdown \"By default the value of `:metamorph/id` is set to a unique uuid. In some cases it can be usefull to overwrite this autogenerated id.\\nThis can be done by pre-pedinding any step function with a map. The map gets merged with the usual context map for this step, before the\\nstep function is executed:\\n\"]], \"403\" [:div [:p] nil nil [:p/markdown \"Conceptually we have three types of functions, they differ by which keys in\\n the context they manipulate.\"]], \"398\" [:div [:p] nil nil [:p/markdown \"The second alternative is to capture the state of the ctx in arbitrary\\n steps.\"]], \"390\" [:div [:p] [:div [:p/code {:code \"(require  '[scicloj.ml.core :as ml]\\n          '[scicloj.ml.metamorph :as mm]\\n          '[scicloj.ml.dataset :as ds]\\n          '[tech.v3.datatype.functional :as fun]\\n          )\", :bg-class \"bg-light\"}]] nil nil], \"377\" [:div [:p] [:div [:p/code {:code \"(def predicted-ctx\\n  (pipe-fn\\n   (merge trained-ctx\\n          {:metamorph/data test-data\\n           :metamorph/mode :transform})))\", :bg-class \"bg-light\"}]] nil nil], \"353\" [:div [:p] nil nil [:p/markdown \"Lets take as an example, a function which encodes a column with a numerical value to 3 categorical values:\\n\\n\\n - < 0         -> :negative\\n - > 0 - 1000  -> :low\\n - > 1000      -> :high\\n\\n \"]], \"409\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn-mm\\n  (ml/pipeline\\n   (mm->cat)))\", :bg-class \"bg-light\"}]] nil nil], \"406\" [:div [:p] nil nil [:p/markdown \"We can define inline a metamorph compliant function as anonymous function.\"]], \"367\" [:div [:p] nil nil [:p/markdown \"Here we create dummy training data, which is like a time series.\\nWe have values for time step 1-10, and want to predict (using the mean),\\nthe value for future timesteps.\\n\"]], \"348\" [:div [:p] nil nil [:p/markdown \"Custom steps in metamorph pipelines are normal Clojure functions.\"]], \"424\" [:div [:p] nil nil [:p/markdown \"### Handling of categorical data\"]], \"220\" [:div [:p] nil nil [:p/markdown \"Two functions in `scicloj.ml` use two further keys with the purpose of model evaluation, see further down in this guide.\"]], \"339\" [:div [:p] nil nil [:p/markdown \"The function `scicloj.ml.core/model` stores the feature-dataset and the inference-target-dataset in the ctx before doing a prediction\\nat keys `:scicloj.metamorph.ml/feature-ds` and  `:scicloj.metamorph.ml/target-ds`\"]], \"412\" [:div [:p] nil nil [:p/markdown \"In this chapter we see how to build a custom metamorph compliant function, which behaves like a simple model.\\nIt takes the mean of the training data and applies this the to the test data.\\n\"]], \"407\" [:div [:p] nil nil [:p/markdown \"Here we first create a function which manipulates the dataset as we want\"]], \"378\" [:div [:p] nil nil [:p/markdown \"This runs the pipeline again and we have the prediction available in :metamorph/data\"]], \"361\" [:div [:p] nil nil [:p/markdown \"The results of applying all 3 pipeline functions is the same.\"]], \"215\" [:div [:p] nil nil [:p/markdown \"`:metamorph/mode` is used by 'model' functions, which get fitted from data or transform data.\\nTwo modes are standardized, namelye: `:fit` and `:transform`. In machine learninig they often are called train / predict.\\n`sciform.ml` requires them to be `:fit` and `:transform`, and\\nthird party libraries should adhere to this convention.\\n\"]], \"397\" [:div [:p] [:div [:p/code {:code \"(def trained-ctx\\n  (pipe-fn {:metamorph/data train-data\\n            :metamorph/mode :fit}))\", :bg-class \"bg-light\"}]] nil nil], \"393\" [:div [:p] nil nil [:p/markdown \"This map can have any key / value, which might be usefull for injecting other static data into the pipeline.\"]], \"417\" [:div [:p] [:div [:p/code {:code \"(def pipe-fn\\n  (ml/pipeline\\n   (mean-model)\\n   ))\", :bg-class \"bg-light\"}]] nil nil], \"351\" [:div [:p] nil nil [:p/markdown \"Most steps of a pipeline are about modifying the dataset, so most custom code will be here.\\nIn machine learning, this is as well known as feature engineering, as new features get created\\nfrom existing features.\"]]}}");
     document.getElementById("loading").remove();
    </script>
</html>
